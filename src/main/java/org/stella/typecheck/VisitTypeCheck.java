// File generated by the BNF Converter (bnfc 2.9.4.1).

package org.stella.typecheck;

import org.stella.typecheck.exception.*;
import org.syntax.stella.Absyn.*;

import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

/*** Visitor Design Pattern Skeleton. ***/

/* This implements the common visitor design pattern.
   Tests show it to be slightly less efficient than the
   instanceof method, but easier to use.
   Replace the R and A parameters with the desired return
   and context types.*/

public class VisitTypeCheck {

    public record FunctionParameter(String identifier, Type type) {
    }

    public record FunctionInfo(String name, Type returnType, ArrayList<FunctionParameter> params) {
    }

    public record TypeVisitorArgs(Type expectedType, String functionName) {
    }

    public record ExprVisitorArgs(
            Type expectedType,
            String functionName,
            Map<String, Type> accessibleVariables,
            ArrayList<FunctionInfo> accessibleFunctions,
            Optional<String> callingFunctionName,
            Optional<List<Expr>> actualParams) {

        public ExprVisitorArgs(Type expectedType, String functionName, Map<String, Type> accessibleVariables, ArrayList<FunctionInfo> accessibleFunctions) {
            this(expectedType, functionName, accessibleVariables, accessibleFunctions, Optional.empty(), Optional.empty());
        }

        public ExprVisitorArgs(Type expectedType, String functionName, Map<String, Type> accessibleVariables, ArrayList<FunctionInfo> accessibleFunctions, String callingFunctionName) {
            this(expectedType, functionName, accessibleVariables, accessibleFunctions, Optional.of(callingFunctionName), Optional.empty());
        }

        public ExprVisitorArgs(Type expectedType, String functionName, Map<String, Type> accessibleVariables, ArrayList<FunctionInfo> accessibleFunctions, List<Expr> actualParams) {
            this(expectedType, functionName, accessibleVariables, accessibleFunctions, Optional.empty(), Optional.of(actualParams));
        }
    }

    public record ParamDeclVisitorArgs(String functionName, List<FunctionParameter> params,
                                       List<String> functionNames, boolean isAnonymousFunction) {
    }

    private Optional<TypeCheckException> checkExprType(ExprVisitorArgs args, Type type) {
        if (!args.expectedType.equals(type)) {
            if (args.callingFunctionName.isPresent()) {
                return Optional.of(TypeMismatchException.invalidArgumentType(args.functionName, args.callingFunctionName.get(), args.expectedType, type));
            } else {
                return Optional.of(TypeMismatchException.wrongType(args.functionName, args.expectedType, type));
            }
        }

        return Optional.empty();
    }

    private static Optional<String> getFirstDuplicate(java.util.List<String> names) {
        Set<String> namesSet = new HashSet<>();
        Optional<String> duplicate = Optional.empty();

        for (String name : names) {
            if (!namesSet.contains(name)) {
                namesSet.add(name);
            } else {
                duplicate = Optional.of(name);
                break;
            }
        }

        return duplicate;
    }

    private static Optional<TypeCheckException> checkFunctionDeclarations(List<FunctionInfo> functions) {

        for (FunctionInfo function : functions) {
            if (function.params.size() != 1)
                return Optional.of(FunctionDeclarationException.illegalParamsCount(function.name, function.params.size(), false));
        }

        List<String> functionNames = functions.stream().map(info -> info.name).toList();

        if (!functionNames.contains("main"))
            return Optional.of(FunctionDeclarationException.noMainMethod());

        Optional<String> duplicateOpt = getFirstDuplicate(functionNames);
        return duplicateOpt.map(FunctionDeclarationException::functionNameDuplicate);
    }

    private static Optional<TypeCheckException> checkParamsNames(ArrayList<String> paramNames, String functionName, List<String> functionNames, boolean isAnonymous) {
        ArrayList<String> paramsAndFunctions = new ArrayList<>(paramNames);
        paramsAndFunctions.addAll(functionNames);

        Optional<String> duplicateOpt = getFirstDuplicate(paramNames);
        if (duplicateOpt.isPresent()) {
            return duplicateOpt
                    .map(duplicate -> FunctionDeclarationException.paramNameDuplicate(duplicate, functionName, isAnonymous));
        } else {
            duplicateOpt = getFirstDuplicate(paramsAndFunctions);
            return duplicateOpt
                    .map(duplicate -> FunctionDeclarationException.paramNameDuplicatesFunctionName(duplicate, functionName, isAnonymous));
        }
    }

    private static Optional<TypeCheckException> acceptNullable(Expr expr, ExprVisitor visitor, ExprVisitorArgs args) {
        Optional<TypeCheckException> nullableResult = expr.accept(visitor, args);
        if (nullableResult == null)
            return Optional.of(NotSupportedExpressionException.unknownExpression(expr));
        else
            return nullableResult;
    }

    public class ProgramVisitor<A> implements org.syntax.stella.Absyn.Program.Visitor<Optional<TypeCheckException>, A> {
        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.AProgram p, A arg) { /* Code for AProgram goes here */
//      p.languagedecl_.accept(new LanguageDeclVisitor<R,A>(), arg);
//      for (org.syntax.stella.Absyn.Extension x: p.listextension_) {
//        x.accept(new ExtensionVisitor<R,A>(), arg);
//      }

            ArrayList<FunctionInfo> functions = new ArrayList<>();
            for (org.syntax.stella.Absyn.Decl x : p.listdecl_) {
                Optional<TypeCheckException> e = x.accept(new DeclVisitor(), functions);
                if (e.isPresent())
                    return e;
            }

            ArrayList<String> functionNames = new ArrayList<>();
            for (FunctionInfo functionInfo : functions) {
                functionNames.add(functionInfo.name);
            }

            Optional<TypeCheckException> e = checkFunctionDeclarations(functions);

            return e;
        }
    }

    public class LanguageDeclVisitor<R, A> implements org.syntax.stella.Absyn.LanguageDecl.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.LanguageCore p, A arg) { /* Code for LanguageCore goes here */
            return null;
        }
    }

    public class ExtensionVisitor<R, A> implements org.syntax.stella.Absyn.Extension.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.AnExtension p, A arg) { /* Code for AnExtension goes here */
            for (String x : p.listextensionname_) {
                //x;
            }
            return null;
        }
    }

    public class DeclVisitor implements org.syntax.stella.Absyn.Decl.Visitor<Optional<TypeCheckException>, ArrayList<FunctionInfo>> {
        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.DeclFun p, ArrayList<FunctionInfo> functions) { /* Code for DeclFun goes here */

            String functionName = p.stellaident_;

            ArrayList<FunctionParameter> params = new ArrayList<>();
            ParamDeclVisitorArgs args = new ParamDeclVisitorArgs(
                    functionName,
                    params,
                    functions.stream().map(f -> f.name).toList(),
                    false);
            for (org.syntax.stella.Absyn.ParamDecl x : p.listparamdecl_) {
                Optional<TypeCheckException> e = x.accept(new ParamDeclVisitor(), args);
                if (e.isPresent())
                    return e;
            }

            Optional<Type> declaredReturnTypeOpt = p.returntype_.accept(new ReturnTypeVisitor<Integer>(), 2);
            if (declaredReturnTypeOpt.isEmpty())
                return Optional.of(FunctionDeclarationException.noReturnType(functionName));

            Type declaredReturnType = declaredReturnTypeOpt.get();
            functions.add(new FunctionInfo(functionName, declaredReturnType, params));

//      for (org.syntax.stella.Absyn.Annotation x: p.listannotation_) {
//        x.accept(new AnnotationVisitor<R,ArrayList<String>>(), arg);
//      }

//      p.throwtype_.accept(new ThrowTypeVisitor<R,A>(), arg);
//      for (org.syntax.stella.Absyn.Decl x: p.listdecl_) {
//        x.accept(new DeclVisitor<R,A>(), arg);
//      }

            Map<String, Type> accessibleVariables = new HashMap<>();
            for (FunctionParameter fp : params)
                accessibleVariables.put(fp.identifier, fp.type);

            ExprVisitorArgs returnExprArgs = new ExprVisitorArgs(
                    declaredReturnType,
                    functionName,
                    accessibleVariables,
                    functions);

            Optional<TypeCheckException> returnTypeException = acceptNullable(p.expr_, new ExprVisitor(), returnExprArgs);

            return returnTypeException;
            //return ReturnTypeMismatchException.returnTypeMismatch(declaredReturnType, returnExprType, functionName);

        }

        public Optional<TypeCheckException> visit(DeclFunGeneric p, ArrayList<FunctionInfo> arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(DeclTypeAlias p, ArrayList<FunctionInfo> arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(DeclExceptionType p, ArrayList<FunctionInfo> arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(DeclExceptionVariant p, ArrayList<FunctionInfo> arg) {
            return null;
        }

    }

    public class LocalDeclVisitor<R, A> implements org.syntax.stella.Absyn.LocalDecl.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.ALocalDecl p, A arg) { /* Code for ALocalDecl goes here */
            //p.decl_.accept(new DeclVisitor(), new ArrayList<>());
            return null;
        }
    }

    public class AnnotationVisitor<R, A> implements org.syntax.stella.Absyn.Annotation.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.InlineAnnotation p, A arg) { /* Code for InlineAnnotation goes here */
            return null;
        }
    }

    public class ParamDeclVisitor implements org.syntax.stella.Absyn.ParamDecl.Visitor<Optional<TypeCheckException>, ParamDeclVisitorArgs> {
        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.AParamDecl p, ParamDeclVisitorArgs args) { /* Code for AParamDecl goes here */
            if (args.params.stream().anyMatch(fp -> fp.identifier.equals(p.stellaident_)))
                return Optional.of(FunctionDeclarationException.paramNameDuplicate(p.stellaident_, args.functionName, args.isAnonymousFunction));

            args.params.add(new FunctionParameter(p.stellaident_, p.type_));
            Optional<TypeCheckException> e = checkParamsNames(
                    new ArrayList<>(
                            args.params.stream().map(fp -> fp.identifier).toList()
                    ),
                    args.functionName,
                    args.functionNames,
                    args.isAnonymousFunction
            );
            //p.type_.accept(new TypeVisitor(), null);
            return e;
        }
    }

    public class ReturnTypeVisitor<A> implements org.syntax.stella.Absyn.ReturnType.Visitor<Optional<Type>, A> {
        public Optional<Type> visit(org.syntax.stella.Absyn.NoReturnType p, A arg) { /* Code for NoReturnType goes here */
            return Optional.empty();
        }

        public Optional<Type> visit(org.syntax.stella.Absyn.SomeReturnType p, A arg) { /* Code for SomeReturnType goes here */
            //p.type_.accept(new TypeVisitor(), arg);
            return Optional.of(p.type_);
        }
    }

    public class ThrowTypeVisitor<R, A> implements org.syntax.stella.Absyn.ThrowType.Visitor<R, Type> {
        public R visit(org.syntax.stella.Absyn.NoThrowType p, Type arg) { /* Code for NoThrowType goes here */
            return null;
        }

        public R visit(org.syntax.stella.Absyn.SomeThrowType p, Type arg) { /* Code for SomeThrowType goes here */
            for (org.syntax.stella.Absyn.Type x : p.listtype_) {
                //x.accept(new TypeVisitor(), arg);
            }
            return null;
        }
    }

    public class TypeVisitor implements org.syntax.stella.Absyn.Type.Visitor<Optional<TypeCheckException>, TypeVisitorArgs> {
        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeFun p, TypeVisitorArgs arg) { /* Code for TypeFun goes here */
            for (org.syntax.stella.Absyn.Type x : p.listtype_) {
                x.accept(new TypeVisitor(), arg);
            }
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public Optional<TypeCheckException> visit(TypeForAll p, TypeVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeRec p, TypeVisitorArgs arg) { /* Code for TypeRec goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeSum p, TypeVisitorArgs arg) { /* Code for TypeSum goes here */
            p.type_1.accept(new TypeVisitor(), arg);
            p.type_2.accept(new TypeVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeTuple p, TypeVisitorArgs arg) { /* Code for TypeTuple goes here */
            for (org.syntax.stella.Absyn.Type x : p.listtype_) {
                x.accept(new TypeVisitor(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeRecord p, TypeVisitorArgs arg) { /* Code for TypeRecord goes here */
            for (org.syntax.stella.Absyn.RecordFieldType x : p.listrecordfieldtype_) {
                //x.accept(new RecordFieldTypeVisitor<R,A>(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeVariant p, TypeVisitorArgs arg) { /* Code for TypeVariant goes here */
            for (org.syntax.stella.Absyn.VariantFieldType x : p.listvariantfieldtype_) {
                //x.accept(new VariantFieldTypeVisitor<R,A>(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeList p, TypeVisitorArgs arg) { /* Code for TypeList goes here */
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeBool p, TypeVisitorArgs args) { /* Code for TypeBool goes here */
            if (!p.equals(args.expectedType))
                return Optional.of(TypeMismatchException.wrongType(args.functionName, args.expectedType, p));

            return Optional.empty();
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeNat p, TypeVisitorArgs arg) { /* Code for TypeNat goes here */
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeUnit p, TypeVisitorArgs arg) { /* Code for TypeUnit goes here */
            return null;
        }

        public Optional<TypeCheckException> visit(TypeTop p, TypeVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(TypeBottom p, TypeVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(TypeRef p, TypeVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeVar p, TypeVisitorArgs arg) { /* Code for TypeVar goes here */
            //p.stellaident_;
            return null;
        }
    }

    public class MatchCaseVisitor<R, A> implements org.syntax.stella.Absyn.MatchCase.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.AMatchCase p, A arg) { /* Code for AMatchCase goes here */
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            //p.expr_.accept(new ExprVisitor<R,A>(), arg);
            return null;
        }
    }

    public class OptionalTypingVisitor<R, A> implements org.syntax.stella.Absyn.OptionalTyping.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.NoTyping p, A arg) { /* Code for NoTyping goes here */
            return null;
        }

        public R visit(org.syntax.stella.Absyn.SomeTyping p, A arg) { /* Code for SomeTyping goes here */
            //p.type_.accept(new TypeVisitor<R,A>(), arg);
            return null;
        }
    }

    public class PatternDataVisitor<R, A> implements org.syntax.stella.Absyn.PatternData.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.NoPatternData p, A arg) { /* Code for NoPatternData goes here */
            return null;
        }

        public R visit(org.syntax.stella.Absyn.SomePatternData p, A arg) { /* Code for SomePatternData goes here */
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }
    }

    public class ExprDataVisitor<R, A> implements org.syntax.stella.Absyn.ExprData.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.NoExprData p, A arg) { /* Code for NoExprData goes here */
            return null;
        }

        public R visit(org.syntax.stella.Absyn.SomeExprData p, A arg) { /* Code for SomeExprData goes here */
            //p.expr_.accept(new ExprVisitor<R,A>(), arg);
            return null;
        }
    }

    public class PatternVisitor<R, A> implements org.syntax.stella.Absyn.Pattern.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.PatternVariant p, A arg) { /* Code for PatternVariant goes here */
            //p.stellaident_;
            p.patterndata_.accept(new PatternDataVisitor<R, A>(), arg);
            return null;
        }

        public R visit(org.syntax.stella.Absyn.PatternInl p, A arg) { /* Code for PatternInl goes here */
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }

        public R visit(org.syntax.stella.Absyn.PatternInr p, A arg) { /* Code for PatternInr goes here */
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }

        public R visit(org.syntax.stella.Absyn.PatternTuple p, A arg) { /* Code for PatternTuple goes here */
            for (org.syntax.stella.Absyn.Pattern x : p.listpattern_) {
                x.accept(new PatternVisitor<R, A>(), arg);
            }
            return null;
        }

        public R visit(org.syntax.stella.Absyn.PatternRecord p, A arg) { /* Code for PatternRecord goes here */
            for (org.syntax.stella.Absyn.LabelledPattern x : p.listlabelledpattern_) {
                x.accept(new LabelledPatternVisitor<R, A>(), arg);
            }
            return null;
        }

        public R visit(org.syntax.stella.Absyn.PatternList p, A arg) { /* Code for PatternList goes here */
            for (org.syntax.stella.Absyn.Pattern x : p.listpattern_) {
                x.accept(new PatternVisitor<R, A>(), arg);
            }
            return null;
        }

        public R visit(org.syntax.stella.Absyn.PatternCons p, A arg) { /* Code for PatternCons goes here */
            p.pattern_1.accept(new PatternVisitor<R, A>(), arg);
            p.pattern_2.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }

        public R visit(org.syntax.stella.Absyn.PatternFalse p, A arg) { /* Code for PatternFalse goes here */
            return null;
        }

        public R visit(org.syntax.stella.Absyn.PatternTrue p, A arg) { /* Code for PatternTrue goes here */
            return null;
        }

        public R visit(org.syntax.stella.Absyn.PatternUnit p, A arg) { /* Code for PatternUnit goes here */
            return null;
        }

        public R visit(org.syntax.stella.Absyn.PatternInt p, A arg) { /* Code for PatternInt goes here */
            //p.integer_;
            return null;
        }

        public R visit(org.syntax.stella.Absyn.PatternSucc p, A arg) { /* Code for PatternSucc goes here */
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }

        public R visit(org.syntax.stella.Absyn.PatternVar p, A arg) { /* Code for PatternVar goes here */
            //p.stellaident_;
            return null;
        }
    }

    public class LabelledPatternVisitor<R, A> implements org.syntax.stella.Absyn.LabelledPattern.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.ALabelledPattern p, A arg) { /* Code for ALabelledPattern goes here */
            //p.stellaident_;
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }
    }

    //  public class BindingVisitor<R,A> implements org.syntax.stella.Absyn.Binding.Visitor<R,A>
//  {
//    public R visit(org.syntax.stella.Absyn.ABinding p, A arg)
//    { /* Code for ABinding goes here */
//      //p.stellaident_;
//      p.expr_.accept(new ExprVisitor<R,A>(), arg);
//      return null;
//    }
//  }
    public class ExprVisitor implements org.syntax.stella.Absyn.Expr.Visitor<Optional<TypeCheckException>, ExprVisitorArgs> {
        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Sequence p, ExprVisitorArgs expectedType) { /* Code for Sequence goes here */
            p.expr_1.accept(new ExprVisitor(), expectedType);
            p.expr_2.accept(new ExprVisitor(), expectedType);
            return null;
        }

        public Optional<TypeCheckException> visit(Assign p, ExprVisitorArgs expectedType) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.If p, ExprVisitorArgs args) { /* Code for If goes here */
            ExprVisitorArgs conditionArgs = new ExprVisitorArgs(
                    new TypeBool(),
                    args.functionName,
                    args.accessibleVariables,
                    args.accessibleFunctions
            );
            Optional<TypeCheckException> wrongCond = acceptNullable(p.expr_1, new ExprVisitor(), conditionArgs);
            Optional<TypeCheckException> wrongArg1 = acceptNullable(p.expr_2, new ExprVisitor(), conditionArgs);
            Optional<TypeCheckException> wrongArg2 = acceptNullable(p.expr_3, new ExprVisitor(), conditionArgs);

            if (wrongCond.isPresent())
                return wrongCond;
            else if (wrongArg1.isPresent())
                return wrongArg1;
            else
                return wrongArg2;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Let p, ExprVisitorArgs arg) { /* Code for Let goes here */
            for (org.syntax.stella.Absyn.PatternBinding x : p.listpatternbinding_) {
                //x.accept(new PatternBindingVisitor<R,A>(), arg);
            }
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.LetRec p, ExprVisitorArgs arg) { /* Code for LetRec goes here */
            for (org.syntax.stella.Absyn.PatternBinding x : p.listpatternbinding_) {
                //x.accept(new PatternBindingVisitor<R,A>(), arg);
            }
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        @Override
        public Optional<TypeCheckException> visit(TypeAbstraction p, ExprVisitorArgs expectedType) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.LessThan p, ExprVisitorArgs arg) { /* Code for LessThan goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.LessThanOrEqual p, ExprVisitorArgs arg) { /* Code for LessThanOrEqual goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.GreaterThan p, ExprVisitorArgs arg) { /* Code for GreaterThan goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.GreaterThanOrEqual p, ExprVisitorArgs arg) { /* Code for GreaterThanOrEqual goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Equal p, ExprVisitorArgs arg) { /* Code for Equal goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.NotEqual p, ExprVisitorArgs arg) { /* Code for NotEqual goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeAsc p, ExprVisitorArgs arg) { /* Code for TypeAsc goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            //p.type_.accept(new TypeVisitor<R,A>(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(TypeCast p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Abstraction p, ExprVisitorArgs args) { /* Code for Abstraction goes here */
            if (p.listparamdecl_.size() != 1)
                return Optional.of(FunctionDeclarationException.illegalParamsCount(args.functionName, p.listparamdecl_.size(), true));

            if (args.expectedType instanceof TypeFun) {

                List<FunctionParameter> accessibleParams = new ArrayList<>(args
                        .accessibleVariables
                        .entrySet()
                        .stream()
                        .map(entry -> new FunctionParameter(entry.getKey(), entry.getValue()))
                        .toList());
                for (org.syntax.stella.Absyn.ParamDecl x : p.listparamdecl_) {
                    Optional<TypeCheckException> paramResult = x.accept(new ParamDeclVisitor(), new ParamDeclVisitorArgs(
                            args.functionName,
                            accessibleParams,
                            args.accessibleFunctions.stream().map(f -> f.name).toList(),
                            true));
                    if (paramResult.isPresent())
                        return paramResult;
                }

                TypeFun expectedType = (TypeFun) args.expectedType;
                Type returnType = expectedType.type_;
                Map<String, Type> extendedVariables = new HashMap<>(args.accessibleVariables);
                extendedVariables.putAll(
                        accessibleParams
                                .stream()
                                .collect(
                                        Collectors.toMap(param -> param.identifier, param -> param.type)
                                )
                );
                ExprVisitorArgs newArgs = new ExprVisitorArgs(
                        returnType,
                        args.functionName,
                        extendedVariables,
                        args.accessibleFunctions
                );
                Optional<TypeCheckException> result = acceptNullable(p.expr_, new ExprVisitor(), newArgs);
                if (result.isPresent())
                    return result;
            } else {
                return Optional.of(TypeMismatchException.unexpectedAbstraction(args.functionName, args.expectedType));
            }

            return Optional.empty();
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Variant p, ExprVisitorArgs arg) { /* Code for Variant goes here */
            //p.stellaident_;
            //p.exprdata_.accept(new ExprDataVisitor<R,A>(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Match p, ExprVisitorArgs arg) { /* Code for Match goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            for (org.syntax.stella.Absyn.MatchCase x : p.listmatchcase_) {
                //x.accept(new MatchCaseVisitor<R,A>(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.List p, ExprVisitorArgs arg) { /* Code for List goes here */
            for (org.syntax.stella.Absyn.Expr x : p.listexpr_) {
                x.accept(new ExprVisitor(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Add p, ExprVisitorArgs arg) { /* Code for Add goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Subtract p, ExprVisitorArgs arg) { /* Code for Subtract goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.LogicOr p, ExprVisitorArgs arg) { /* Code for LogicOr goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Multiply p, ExprVisitorArgs arg) { /* Code for Multiply goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Divide p, ExprVisitorArgs arg) { /* Code for Divide goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.LogicAnd p, ExprVisitorArgs arg) { /* Code for LogicAnd goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(Ref p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(Deref p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Application p, ExprVisitorArgs args) { /* Code for Application goes here */

            List<Expr> actualParameters = p.listexpr_;

            ExprVisitorArgs newArgs = new ExprVisitorArgs(
                    args.expectedType,
                    args.functionName,
                    args.accessibleVariables,
                    args.accessibleFunctions,
                    actualParameters);

            return p.expr_.accept(new ExprVisitor(), newArgs);
        }

        @Override
        public Optional<TypeCheckException> visit(TypeApplication p, ExprVisitorArgs expectedType) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.DotRecord p, ExprVisitorArgs arg) { /* Code for DotRecord goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            //p.stellaident_;
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.DotTuple p, ExprVisitorArgs arg) { /* Code for DotTuple goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            //p.integer_;
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Tuple p, ExprVisitorArgs arg) { /* Code for Tuple goes here */
            for (org.syntax.stella.Absyn.Expr x : p.listexpr_) {
                x.accept(new ExprVisitor(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Record p, ExprVisitorArgs arg) { /* Code for Record goes here */
            for (org.syntax.stella.Absyn.Binding x : p.listbinding_) {
                //x.accept(new BindingVisitor<R,A>(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.ConsList p, ExprVisitorArgs arg) { /* Code for ConsList goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Head p, ExprVisitorArgs arg) { /* Code for Head goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.IsEmpty p, ExprVisitorArgs arg) { /* Code for IsEmpty goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Tail p, ExprVisitorArgs arg) { /* Code for Tail goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(Panic p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(Throw p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(TryCatch p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(TryWith p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Inl p, ExprVisitorArgs arg) { /* Code for Inl goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Inr p, ExprVisitorArgs arg) { /* Code for Inr goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Succ p, ExprVisitorArgs args) { /* Code for Succ goes here */
            Type typeNat = new TypeNat();

            String functionName = p.getClass().getSimpleName();

            if (!args.expectedType.equals(typeNat)) {
                return Optional.of(TypeMismatchException.invalidArgumentType(args.functionName, functionName, args.expectedType, typeNat));
            }

            Optional<TypeCheckException> exprTypeException = checkExprType(args, typeNat); // TODO: use checkExpr type here and everywhere
            if (exprTypeException.isPresent())
                return exprTypeException;

            ExprVisitorArgs newArgs = new ExprVisitorArgs(typeNat,
                    args.functionName,
                    args.accessibleVariables,
                    args.accessibleFunctions,
                    functionName);

            return p.expr_.accept(new ExprVisitor(), newArgs);
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.LogicNot p, ExprVisitorArgs arg) { /* Code for LogicNot goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Pred p, ExprVisitorArgs arg) { /* Code for Pred goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.IsZero p, ExprVisitorArgs arg) { /* Code for IsZero goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Fix p, ExprVisitorArgs arg) { /* Code for Fix goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.NatRec p, ExprVisitorArgs arg) { /* Code for NatRec goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            p.expr_3.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Fold p, ExprVisitorArgs arg) { /* Code for Fold goes here */
            // p.type_.accept(new TypeVisitor<R,A>(), arg);
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Unfold p, ExprVisitorArgs arg) { /* Code for Unfold goes here */
            //p.type_.accept(new TypeVisitor<R,A>(), arg);
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.ConstTrue p, ExprVisitorArgs args) { /* Code for ConstTrue goes here */
            TypeBool typeBool = new TypeBool();

            return checkExprType(args, typeBool);
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.ConstFalse p, ExprVisitorArgs args) { /* Code for ConstFalse goes here */
            TypeBool typeBool = new TypeBool();

            return checkExprType(args, typeBool);
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.ConstUnit p, ExprVisitorArgs arg) { /* Code for ConstUnit goes here */
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.ConstInt p, ExprVisitorArgs arg) { /* Code for ConstInt goes here */
            //p.integer_;
            return null;
        }

        public Optional<TypeCheckException> visit(ConstMemory p, ExprVisitorArgs arg) {
            return null;
        }

        private Optional<TypeCheckException> checkAppliedFunction(String identifier, Type returnType, List<Type> paramTypes, ExprVisitorArgs args) {
            Optional<TypeCheckException> typeException = checkExprType(args, returnType);
            if (typeException.isPresent())
                return typeException;

            if (args.actualParams.isPresent() && args.actualParams.get().size() == 1) {
                List<Expr> actualParams = args.actualParams.get();

                for (int i = 0; i < actualParams.size(); i++) {
                    ExprVisitorArgs argsForParameter = new ExprVisitorArgs(
                            paramTypes.get(i),
                            args.functionName,
                            args.accessibleVariables,
                            args.accessibleFunctions,
                            identifier
                    );
                    Optional<TypeCheckException> result = actualParams.get(i).accept(new ExprVisitor(), argsForParameter);
                    if (result.isPresent())
                        return result;
                }
            } else {
                return Optional.of(FunctionDeclarationException.illegalParamsCount(identifier, args.actualParams.map(List::size).orElse(0), false));
            }

            return Optional.empty();
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Var p, ExprVisitorArgs args) { /* Code for Var goes here */
            String identifier = p.stellaident_;

            if (args.accessibleVariables.containsKey(identifier)) {
                Type variableType = args.accessibleVariables.get(identifier);
                if (variableType instanceof TypeFun) {
                    System.out.println("YES!"); // TODO: finish
                    TypeFun typeFun = (TypeFun) variableType;
                    Type returnType = typeFun.type_;
                    List<Type> paramTypes = typeFun.listtype_;
                    return checkAppliedFunction(identifier, returnType, paramTypes, args);

                } else {
                    return checkExprType(args, variableType);
                }
            } else {
                Optional<FunctionInfo> appliedFunctionOpt = args.accessibleFunctions.stream().filter(f -> f.name.equals(identifier)).findFirst();
                if (appliedFunctionOpt.isPresent()) {
                    FunctionInfo appliedFunction = appliedFunctionOpt.get();

                    return checkAppliedFunction(
                            identifier,
                            appliedFunction.returnType,
                            appliedFunction.params.stream().map(param -> param.type).toList(),
                            args);

//                    Optional<TypeCheckException> typeException = checkExprType(args, appliedFunction.returnType);
//                    if (typeException.isPresent())
//                        return typeException;
//
//
//                    if (args.actualParams.isPresent() && args.actualParams.get().size() == 1) {
//                        List<Expr> actualParams = args.actualParams.get();
//
//                        for (int i = 0; i < actualParams.size(); i++) {
//                            ExprVisitorArgs argsForParameter = new ExprVisitorArgs(
//                                    appliedFunction.params.get(i).type,
//                                    args.functionName,
//                                    args.accessibleVariables,
//                                    args.accessibleFunctions,
//                                    identifier
//                            );
//                            Optional<TypeCheckException> result = actualParams.get(i).accept(new ExprVisitor(), argsForParameter);
//                            if (result.isPresent())
//                                return result;
//                        }
//                    } else {
//                        return Optional.of(FunctionDeclarationException.illegalParamsCount(identifier, args.actualParams.map(List::size).orElse(0), false));
//                    }
                } else {
                    return Optional.of(UnknownIdentifierException.unknownVariable(identifier, args.functionName));
                }
            }
        }
    }

    public class PatternBindingVisitor<R, A> implements org.syntax.stella.Absyn.PatternBinding.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.APatternBinding p, A arg) { /* Code for APatternBinding goes here */
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            //p.expr_.accept(new ExprVisitor<R,A>(), arg);
            return null;
        }
    }

    public class VariantFieldTypeVisitor<R, A> implements org.syntax.stella.Absyn.VariantFieldType.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.AVariantFieldType p, A arg) { /* Code for AVariantFieldType goes here */
            //p.stellaident_;
            p.optionaltyping_.accept(new OptionalTypingVisitor<R, A>(), arg);
            return null;
        }
    }

    public class RecordFieldTypeVisitor<R, A> implements org.syntax.stella.Absyn.RecordFieldType.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.ARecordFieldType p, A arg) { /* Code for ARecordFieldType goes here */
            //p.stellaident_;
            //p.type_.accept(new TypeVisitor<R,A>(), arg);
            return null;
        }
    }

    public class TypingVisitor<R, A> implements org.syntax.stella.Absyn.Typing.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.ATyping p, A arg) { /* Code for ATyping goes here */
            //p.expr_.accept(new ExprVisitor<R,A>(), arg);
            //p.type_.accept(new TypeVisitor(), arg);
            return null;
        }
    }
}
