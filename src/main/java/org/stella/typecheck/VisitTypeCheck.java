// File generated by the BNF Converter (bnfc 2.9.4.1).

package org.stella.typecheck;

import org.stella.typecheck.exception.*;
import org.syntax.stella.Absyn.*;

import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

/*** Visitor Design Pattern Skeleton. ***/

/* This implements the common visitor design pattern.
   Tests show it to be slightly less efficient than the
   instanceof method, but easier to use.
   Replace the R and A parameters with the desired return
   and context types.*/

public class VisitTypeCheck {

    private final Set<String> extensions = new HashSet<>();

    public record FunctionParameter(String identifier, Type type) {
    }

    public record FunctionInfo(String name, Type returnType, ArrayList<FunctionParameter> params) {
    }

    public record TypeVisitorArgs(Type expectedType, String functionName) {
    }

    public record ExprVisitorArgs(
            Type expectedType,
            String functionName,
            Map<String, Type> accessibleVariables,
            List<FunctionInfo> accessibleFunctions,
            Stack<Operation> operations,
            Optional<String> callingFunctionName,
            Optional<Type> natRecType) {

        public ExprVisitorArgs(Type expectedType, String functionName, Map<String, Type> accessibleVariables, List<FunctionInfo> accessibleFunctions, Stack<Operation> operations) {
            this(expectedType, functionName, accessibleVariables, accessibleFunctions, operations, Optional.empty(), Optional.empty());
        }

        public ExprVisitorArgs(Type expectedType, String functionName, Map<String, Type> accessibleVariables, List<FunctionInfo> accessibleFunctions, Stack<Operation> operations, String callingFunctionName) {
            this(expectedType, functionName, accessibleVariables, accessibleFunctions, operations, Optional.of(callingFunctionName), Optional.empty());
        }

        public ExprVisitorArgs(Type expectedType, String functionName, Map<String, Type> accessibleVariables, List<FunctionInfo> accessibleFunctions, Stack<Operation> operations, Type natRecType) {
            this(expectedType, functionName, accessibleVariables, accessibleFunctions, operations, Optional.empty(), Optional.of(natRecType));
        }
    }

    public record MatchCaseVisitorArgs(
            Type parentExprType,
            Type expectedType,
            Map<String, Type> accessibleVariables,
            List<FunctionInfo> accessibleFunctions,
            String functionName) {
    }

    public record PatternVisitorArgs(
            Type parentExprType,
            Map<String, Type> accessibleVariables,
            List<FunctionInfo> accessibleFunctions,
            String functionName) {
    }

    public record ParamDeclVisitorArgs(Optional<Type> expectedType, String functionName, List<FunctionParameter> params,
                                       List<String> functionNames, boolean isAnonymousFunction) {
        public ParamDeclVisitorArgs(String functionName, List<FunctionParameter> params,
                                    List<String> functionNames, boolean isAnonymousFunction) {
            this(Optional.empty(), functionName, params, functionNames, isAnonymousFunction);
        }
    }

    private Optional<TypeCheckException> getTypeMismatchException(ExprVisitorArgs args, Type type) {
        if (args.callingFunctionName.isPresent()) {
            return Optional.of(TypeMismatchException.invalidArgumentType(args.functionName, args.callingFunctionName.get(), args.expectedType, type));
        } else {
            return Optional.of(TypeMismatchException.wrongType(args.functionName, args.expectedType, type));
        }
    }

    private Optional<TypeCheckException> checkExprType(ExprVisitorArgs args, Type type) {
        if (args.expectedType == null)
            return Optional.empty();

        if ((type instanceof TypeTuple) && (args.expectedType instanceof TypeTuple)) {
            ListType expectedList = ((TypeTuple) args.expectedType).listtype_;
            ListType actualList = ((TypeTuple) type).listtype_;
            for (int i = 0; i < expectedList.size(); i++) {
                if (expectedList.get(i) == null)
                    continue;
                if (!expectedList.get(i).equals(actualList.get(i))) {
                    return Optional.of(TypeMismatchException.wrongType(args.functionName, args.expectedType, type));
                }
            }
        } else if (!args.expectedType.equals(type)) {
            return getTypeMismatchException(args, type);
        }

        return Optional.empty();
    }

    private Optional<TypeCheckException> compareTypes(TypeVisitorArgs args, Type type) {
        if (!args.expectedType.equals(type))
            return Optional.of(TypeMismatchException.wrongType(args.functionName, args.expectedType, type));

        return Optional.empty();
    }

    private static Optional<String> getFirstDuplicate(java.util.List<String> names) {
        Set<String> namesSet = new HashSet<>();
        Optional<String> duplicate = Optional.empty();

        for (String name : names) {
            if (!namesSet.contains(name)) {
                namesSet.add(name);
            } else {
                duplicate = Optional.of(name);
                break;
            }
        }

        return duplicate;
    }

    private static Optional<TypeCheckException> checkFunctionDeclarations(List<FunctionInfo> functions) {

        for (FunctionInfo function : functions) {
            if (function.params.size() != 1)
                return Optional.of(FunctionDeclarationException.illegalParamsCount(function.name, function.params.size(), false));
        }

        List<String> functionNames = functions.stream().map(info -> info.name).toList();

        if (!functionNames.contains("main"))
            return Optional.of(FunctionDeclarationException.noMainMethod());

        Optional<String> duplicateOpt = getFirstDuplicate(functionNames);
        return duplicateOpt.map(FunctionDeclarationException::functionNameDuplicate);
    }

    private static Optional<TypeCheckException> checkParamsNames(ArrayList<String> paramNames, String functionName, List<String> functionNames, boolean isAnonymous) {
        ArrayList<String> paramsAndFunctions = new ArrayList<>(paramNames);
        paramsAndFunctions.addAll(functionNames);

        Optional<String> duplicateOpt = getFirstDuplicate(paramNames);
        if (duplicateOpt.isPresent()) {
            return duplicateOpt
                    .map(duplicate -> FunctionDeclarationException.paramNameDuplicate(duplicate, functionName, isAnonymous));
        } else {
            duplicateOpt = getFirstDuplicate(paramsAndFunctions);
            return duplicateOpt
                    .map(duplicate -> FunctionDeclarationException.paramNameDuplicatesFunctionName(duplicate, functionName, isAnonymous));
        }
    }

    private static Optional<TypeCheckException> acceptNullable(Expr expr, ExprVisitor visitor, ExprVisitorArgs args) {
        if (args.expectedType == null)
            return Optional.empty();
        Optional<TypeCheckException> nullableResult = expr.accept(visitor, args);
        if (nullableResult == null)
            return Optional.of(NotSupportedException.unknownExpression(expr));
        else
            return nullableResult;
    }

    private Optional<TypeCheckException> checkExtension(String requiredExtension, Type type, ExprVisitorArgs args) {
        if (!extensions.contains(requiredExtension)) {
            return Optional.of(MissingExtensionException.noExtensionForType(args.functionName, requiredExtension, type));
        }
        return Optional.empty();
    }

    public class ProgramVisitor<A> implements org.syntax.stella.Absyn.Program.Visitor<Optional<TypeCheckException>, A> {
        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.AProgram p, A arg) { /* Code for AProgram goes here */
//      p.languagedecl_.accept(new LanguageDeclVisitor<R,A>(), arg);
            for (org.syntax.stella.Absyn.Extension x : p.listextension_) {
                x.accept(new ExtensionVisitor(), arg);
            }

            ArrayList<FunctionInfo> functions = new ArrayList<>();
            for (org.syntax.stella.Absyn.Decl x : p.listdecl_) {
                Optional<TypeCheckException> e = x.accept(new DeclVisitor(), functions);
                if (e.isPresent())
                    return e;
            }

            ArrayList<String> functionNames = new ArrayList<>();
            for (FunctionInfo functionInfo : functions) {
                functionNames.add(functionInfo.name);
            }

            Optional<TypeCheckException> e = checkFunctionDeclarations(functions);

            return e;
        }
    }

    public class LanguageDeclVisitor<R, A> implements org.syntax.stella.Absyn.LanguageDecl.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.LanguageCore p, A arg) { /* Code for LanguageCore goes here */
            return null;
        }
    }

    public class ExtensionVisitor implements org.syntax.stella.Absyn.Extension.Visitor {
        @Override
        public Object visit(AnExtension p, Object arg) {
            extensions.addAll(p.listextensionname_);
            return null;
        }
    }

    public class DeclVisitor implements org.syntax.stella.Absyn.Decl.Visitor<Optional<TypeCheckException>, ArrayList<FunctionInfo>> {
        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.DeclFun p, ArrayList<FunctionInfo> functions) { /* Code for DeclFun goes here */

            String functionName = p.stellaident_;

            ArrayList<FunctionParameter> params = new ArrayList<>();
            ParamDeclVisitorArgs args = new ParamDeclVisitorArgs(
                    functionName,
                    params,
                    functions.stream().map(f -> f.name).toList(),
                    false);
            for (org.syntax.stella.Absyn.ParamDecl x : p.listparamdecl_) {
                Optional<TypeCheckException> e = x.accept(new ParamDeclVisitor(), args);
                if (e.isPresent())
                    return e;
            }

            Optional<Type> declaredReturnTypeOpt = p.returntype_.accept(new ReturnTypeVisitor<Integer>(), 2);
            if (declaredReturnTypeOpt.isEmpty())
                return Optional.of(FunctionDeclarationException.noReturnType(functionName));

            Type declaredReturnType = declaredReturnTypeOpt.get();
            functions.add(new FunctionInfo(functionName, declaredReturnType, params));

//      for (org.syntax.stella.Absyn.Annotation x: p.listannotation_) {
//        x.accept(new AnnotationVisitor<R,ArrayList<String>>(), arg);
//      }

//      p.throwtype_.accept(new ThrowTypeVisitor<R,A>(), arg);
//      for (org.syntax.stella.Absyn.Decl x: p.listdecl_) {
//        x.accept(new DeclVisitor<R,A>(), arg);
//      }

            Map<String, Type> accessibleVariables = new HashMap<>();
            for (FunctionParameter fp : params)
                accessibleVariables.put(fp.identifier, fp.type);

            ExprVisitorArgs returnExprArgs = new ExprVisitorArgs(
                    declaredReturnType,
                    functionName,
                    accessibleVariables,
                    functions,
                    new Stack<>());

            return acceptNullable(p.expr_, new ExprVisitor(), returnExprArgs);
            //return ReturnTypeMismatchException.returnTypeMismatch(declaredReturnType, returnExprType, functionName);

        }

        public Optional<TypeCheckException> visit(DeclFunGeneric p, ArrayList<FunctionInfo> arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(DeclTypeAlias p, ArrayList<FunctionInfo> arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(DeclExceptionType p, ArrayList<FunctionInfo> arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(DeclExceptionVariant p, ArrayList<FunctionInfo> arg) {
            return null;
        }

    }

    public class LocalDeclVisitor<R, A> implements org.syntax.stella.Absyn.LocalDecl.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.ALocalDecl p, A arg) { /* Code for ALocalDecl goes here */
            //p.decl_.accept(new DeclVisitor(), new ArrayList<>());
            return null;
        }
    }

    public class AnnotationVisitor<R, A> implements org.syntax.stella.Absyn.Annotation.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.InlineAnnotation p, A arg) { /* Code for InlineAnnotation goes here */
            return null;
        }
    }

    public class ParamDeclVisitor implements org.syntax.stella.Absyn.ParamDecl.Visitor<Optional<TypeCheckException>, ParamDeclVisitorArgs> {
        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.AParamDecl p, ParamDeclVisitorArgs args) { /* Code for AParamDecl goes here */
            if (args.params.stream().anyMatch(fp -> fp.identifier.equals(p.stellaident_)))
                return Optional.of(FunctionDeclarationException.paramNameDuplicate(p.stellaident_, args.functionName, args.isAnonymousFunction));

            args.params.add(new FunctionParameter(p.stellaident_, p.type_));
            Optional<TypeCheckException> e = checkParamsNames(
                    new ArrayList<>(
                            args.params.stream().map(fp -> fp.identifier).toList()
                    ),
                    args.functionName,
                    args.functionNames,
                    args.isAnonymousFunction
            );

            if (args.expectedType.isPresent()) {
                Optional<TypeCheckException> result = p.type_.accept(new TypeVisitor(), new TypeVisitorArgs(args.expectedType.get(), args.functionName));
                if (result == null)
                    return Optional.of(NotSupportedException.unknownType(p.type_));
                return result;
            }

            return e;
        }
    }

    public class ReturnTypeVisitor<A> implements org.syntax.stella.Absyn.ReturnType.Visitor<Optional<Type>, A> {
        public Optional<Type> visit(org.syntax.stella.Absyn.NoReturnType p, A arg) { /* Code for NoReturnType goes here */
            return Optional.empty();
        }

        public Optional<Type> visit(org.syntax.stella.Absyn.SomeReturnType p, A arg) { /* Code for SomeReturnType goes here */
            //p.type_.accept(new TypeVisitor(), arg);
            return Optional.of(p.type_);
        }
    }

    public class ThrowTypeVisitor<R, A> implements org.syntax.stella.Absyn.ThrowType.Visitor<R, Type> {
        public R visit(org.syntax.stella.Absyn.NoThrowType p, Type arg) { /* Code for NoThrowType goes here */
            return null;
        }

        public R visit(org.syntax.stella.Absyn.SomeThrowType p, Type arg) { /* Code for SomeThrowType goes here */
            for (org.syntax.stella.Absyn.Type x : p.listtype_) {
                //x.accept(new TypeVisitor(), arg);
            }
            return null;
        }
    }

    public class TypeVisitor implements org.syntax.stella.Absyn.Type.Visitor<Optional<TypeCheckException>, TypeVisitorArgs> {
        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeFun p, TypeVisitorArgs args) { /* Code for TypeFun goes here */
            for (org.syntax.stella.Absyn.Type x : p.listtype_) {
                x.accept(new TypeVisitor(), args);
            }
            p.type_.accept(new TypeVisitor(), args);
            return null;
        }

        @Override
        public Optional<TypeCheckException> visit(TypeForAll p, TypeVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeRec p, TypeVisitorArgs arg) { /* Code for TypeRec goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeSum p, TypeVisitorArgs arg) { /* Code for TypeSum goes here */
            p.type_1.accept(new TypeVisitor(), arg);
            p.type_2.accept(new TypeVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeTuple p, TypeVisitorArgs arg) { /* Code for TypeTuple goes here */
            for (org.syntax.stella.Absyn.Type x : p.listtype_) {
                x.accept(new TypeVisitor(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeRecord p, TypeVisitorArgs arg) { /* Code for TypeRecord goes here */
            for (org.syntax.stella.Absyn.RecordFieldType x : p.listrecordfieldtype_) {
                //x.accept(new RecordFieldTypeVisitor<R,A>(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeVariant p, TypeVisitorArgs arg) { /* Code for TypeVariant goes here */
            for (org.syntax.stella.Absyn.VariantFieldType x : p.listvariantfieldtype_) {
                //x.accept(new VariantFieldTypeVisitor<R,A>(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeList p, TypeVisitorArgs arg) { /* Code for TypeList goes here */
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeBool p, TypeVisitorArgs args) { /* Code for TypeBool goes here */
            if (!p.equals(args.expectedType))
                return Optional.of(TypeMismatchException.wrongType(args.functionName, args.expectedType, p));

            return Optional.empty();
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeNat p, TypeVisitorArgs args) { /* Code for TypeNat goes here */
            return checkExprType(new ExprVisitorArgs(
                            args.expectedType,
                            args.functionName,
                            null,
                            null,
                            null),
                    p);
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeUnit p, TypeVisitorArgs args) { /* Code for TypeUnit goes here */
            if (!p.equals(args.expectedType))
                return Optional.of(TypeMismatchException.wrongType(args.functionName, args.expectedType, p));

            return Optional.empty();
        }

        public Optional<TypeCheckException> visit(TypeTop p, TypeVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(TypeBottom p, TypeVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(TypeRef p, TypeVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeVar p, TypeVisitorArgs arg) { /* Code for TypeVar goes here */
            //p.stellaident_;
            return null;
        }
    }

    public class MatchCaseVisitor implements org.syntax.stella.Absyn.MatchCase.Visitor<Optional<TypeCheckException>, MatchCaseVisitorArgs> {
        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.AMatchCase p, MatchCaseVisitorArgs args) { /* Code for AMatchCase goes here */
            Type parentExprType = args.parentExprType;

            PatternVisitorArgs patternArgs = new PatternVisitorArgs(
                    parentExprType,
                    new HashMap<>(args.accessibleVariables),
                    args.accessibleFunctions,
                    args.functionName
            );
            Optional<TypeCheckException> problem = p.pattern_.accept(new PatternVisitor(), patternArgs);
            if (problem.isPresent())
                return problem;
            Map<String, Type> updatedAccessibleVariables = patternArgs.accessibleVariables;

            ExprVisitorArgs newArgs = new ExprVisitorArgs(
                    args.expectedType,
                    args.functionName,
                    updatedAccessibleVariables,
                    args.accessibleFunctions,
                    new Stack<>()
            );
            return p.expr_.accept(new ExprVisitor(), newArgs);
        }
    }

    public class OptionalTypingVisitor<R, A> implements org.syntax.stella.Absyn.OptionalTyping.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.NoTyping p, A arg) { /* Code for NoTyping goes here */
            return null;
        }

        public R visit(org.syntax.stella.Absyn.SomeTyping p, A arg) { /* Code for SomeTyping goes here */
            //p.type_.accept(new TypeVisitor<R,A>(), arg);
            return null;
        }
    }

    public class PatternDataVisitor<R, A> implements org.syntax.stella.Absyn.PatternData.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.NoPatternData p, A arg) { /* Code for NoPatternData goes here */
            return null;
        }

        public R visit(org.syntax.stella.Absyn.SomePatternData p, A arg) { /* Code for SomePatternData goes here */
            //p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }
    }

    public class ExprDataVisitor<R, A> implements org.syntax.stella.Absyn.ExprData.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.NoExprData p, A arg) { /* Code for NoExprData goes here */
            return null;
        }

        public R visit(org.syntax.stella.Absyn.SomeExprData p, A arg) { /* Code for SomeExprData goes here */
            //p.expr_.accept(new ExprVisitor<R,A>(), arg);
            return null;
        }
    }

    private Optional<FunctionInfo> getFunctionByName(List<FunctionInfo> accessibleFunctions, String identifier) {
        return accessibleFunctions
                .stream()
                .filter(f -> f.name.equals(identifier))
                .findFirst();
    }

    public enum OperationType {
        APPLICATION,
        DOT_TUPLE_CALL
    }

    public static abstract class Operation {
        public OperationType type;

        public Operation(OperationType type) {
            this.type = type;
        }
    }

    public static class DotTupleCall extends Operation {
        private final int dotTupleInteger;

        public DotTupleCall(int dotTupleInteger) {
            super(OperationType.DOT_TUPLE_CALL);
            this.dotTupleInteger = dotTupleInteger;
        }

        public int getDotTupleInteger() {
            return dotTupleInteger;
        }
    }

    public static class Application extends Operation {
        private List<Expr> actualParams;

        public Application(List<Expr> actualParams) {
            super(OperationType.APPLICATION);
            this.actualParams = actualParams;
        }

        public List<Expr> getActualParams() {
            return actualParams;
        }
    }

    // f(x).1(e)(r).2.1

    private Type getType(Expr expr,
                         String functionName,
                         Map<String, Type> accessibleVariables,
                         List<FunctionInfo> accessibleFunctions,
                         Stack<Operation> operations) throws TypeCheckException {
        if (expr instanceof Var var) {
            String identifier = var.stellaident_;

            if (!operations.isEmpty()) {
                Type returnType;
                if (accessibleVariables.containsKey(identifier)) {
                    returnType = accessibleVariables.get(identifier);
                } else {
                    Optional<FunctionInfo> calledFunctionOpt = getFunctionByName(accessibleFunctions, identifier);

                    if (calledFunctionOpt.isPresent()) {
                        returnType = calledFunctionOpt.get().returnType;
                    } else {
                        throw UnknownIdentifierException.unknownVariable(identifier, functionName);
                    }
                }

                Operation operation;

                while (!operations.isEmpty()) {
                    operation = operations.pop();
                    if (operation instanceof DotTupleCall dotTupleCall) {
                        if (returnType instanceof TypeTuple tuple) {
                            returnType = tuple.listtype_.get(dotTupleCall.dotTupleInteger - 1);
                        } else {
                            throw IllegalExpressionException.nonTupleDotCall(functionName);
                        }
                    } else {
                        if (returnType instanceof TypeFun fun) {
                            returnType = fun.type_;
                        } else {
                            throw IllegalExpressionException.paramsToNonFunction(functionName, identifier);
                        }
                    }
                }

                return returnType;
            } else {
                if (accessibleVariables.containsKey(identifier)) {
                    return accessibleVariables.get(identifier);
                } else {
                    Optional<FunctionInfo> calledFunctionOpt = getFunctionByName(accessibleFunctions, identifier);

                    if (calledFunctionOpt.isPresent()) {
                        return calledFunctionOpt.get().returnType;
                    } else {
                        throw UnknownIdentifierException.unknownVariable(identifier, functionName);
                    }
                }
            }
        } else if (expr instanceof org.syntax.stella.Absyn.Application application) {
            operations.push(new Application(null));
            return getType(
                    application.expr_,
                    functionName,
                    accessibleVariables,
                    accessibleFunctions,
                    operations);
        } else if (expr instanceof DotTuple dotTuple) {
            operations.push(new DotTupleCall(dotTuple.integer_));
            return getType(
                    dotTuple.expr_,
                    functionName,
                    accessibleVariables,
                    accessibleFunctions,
                    operations);
        } else if (expr instanceof IsZero) {
            return new TypeBool();
        } else if (expr instanceof ConstUnit) {
            return new TypeUnit();
        } else if (expr instanceof ConstInt) {
            return new TypeNat();
        } else if (expr instanceof Succ) {
            return new TypeNat();
        } else if (expr instanceof Abstraction abstraction) {
            List<FunctionParameter> params = new ArrayList<>();
            for (ParamDecl param : abstraction.listparamdecl_) {
                ParamDeclVisitorArgs paramArgs = new ParamDeclVisitorArgs(
                        "anonymous function",
                        params,
                        accessibleFunctions.stream().map(f -> f.name).toList(),
                        true
                );
                param.accept(new ParamDeclVisitor(), paramArgs);
            }

            ListType paramTypes = new ListType();
            paramTypes.addAll(params.stream().map(p -> p.type).toList());

            return new TypeFun(
                    paramTypes,
                    getType(
                            abstraction.expr_,
                            functionName,
                            accessibleVariables,
                            accessibleFunctions,
                            operations));
        } else if (expr instanceof NatRec natRec) {
            return getType(natRec.expr_2,
                    functionName,
                    accessibleVariables,
                    accessibleFunctions,
                    operations);
        } else if (expr instanceof ConstTrue) {
            return new TypeBool();
        } else if (expr instanceof ConstFalse) {
            return new TypeBool();
        } else if (expr instanceof If ifExpr) {
            return getType(ifExpr.expr_2,
                    functionName,
                    accessibleVariables,
                    accessibleFunctions,
                    operations);
        } else if (expr instanceof Inl inl) {
            return getType(inl.expr_,
                    functionName,
                    accessibleVariables,
                    accessibleFunctions,
                    operations);
        } else if (expr instanceof Inr inr) {
            return getType(inr.expr_,
                    functionName,
                    accessibleVariables,
                    accessibleFunctions,
                    operations);
        } else {
            throw IllegalExpressionException.illegalExprInMatch(functionName, expr);
        }
    }

    private TypeSum getSumType(Expr expr,
                               String functionName,
                               Map<String, Type> accessibleVariables,
                               List<FunctionInfo> accessibleFunctions,
                               Stack<Operation> operations) throws TypeCheckException {
        if (expr instanceof Var var) {
            String identifier = var.stellaident_;

            if (!operations.isEmpty()) {
                Type returnType;
                if (accessibleVariables.containsKey(identifier)) {
                    returnType = accessibleVariables.get(identifier);
                } else {
                    Optional<FunctionInfo> calledFunctionOpt = getFunctionByName(accessibleFunctions, identifier);

                    if (calledFunctionOpt.isPresent()) {
                        returnType = calledFunctionOpt.get().returnType;
                    } else {
                        throw UnknownIdentifierException.unknownVariable(identifier, functionName);
                    }
                }

                Operation operation;

                while (!operations.isEmpty()) {
                    operation = operations.pop();
                    if (operation instanceof DotTupleCall dotTupleCall) {
                        if (returnType instanceof TypeTuple tuple) {
                            returnType = tuple.listtype_.get(dotTupleCall.dotTupleInteger - 1);
                        } else {
                            throw IllegalExpressionException.nonTupleDotCall(functionName);
                        }
                    } else {
                        if (returnType instanceof TypeFun fun) {
                            returnType = fun.type_;
                        } else {
                            throw IllegalExpressionException.paramsToNonFunction(functionName, identifier);
                        }
                    }
                }

                if (returnType instanceof TypeSum validType) {
                    return validType;
                } else {
                    throw IllegalExpressionException.illegalExprInMatch(functionName, returnType);
                }
            } else {
                if (accessibleVariables.containsKey(identifier)) {
                    Type varType = accessibleVariables.get(identifier);
                    if (varType instanceof TypeSum validType) {
                        return validType;
                    } else {
                        throw IllegalExpressionException.illegalExprInMatch(functionName, varType);
                    }
                } else {
                    Optional<FunctionInfo> calledFunctionOpt = getFunctionByName(accessibleFunctions, identifier);

                    if (calledFunctionOpt.isPresent()) {
                        Type funReturnType = calledFunctionOpt.get().returnType;
                        if (funReturnType instanceof TypeSum validType) {
                            return validType;
                        } else {
                            throw IllegalExpressionException.illegalExprInMatch(functionName, funReturnType);
                        }
                    } else {
                        throw UnknownIdentifierException.unknownVariable(identifier, functionName);
                    }
                }
            }
        } else if (expr instanceof org.syntax.stella.Absyn.Application application) {
            operations.push(new Application(null));
            return getSumType(
                    application.expr_,
                    functionName,
                    accessibleVariables,
                    accessibleFunctions,
                    operations);
        } else if (expr instanceof DotTuple dotTuple) {
            operations.push(new DotTupleCall(dotTuple.integer_));
            return getSumType(
                    dotTuple.expr_,
                    functionName,
                    accessibleVariables,
                    accessibleFunctions,
                    operations);
        } else {
            throw IllegalExpressionException.illegalExprInMatch(functionName, expr);
        }
    }

    public class PatternVisitor implements org.syntax.stella.Absyn.Pattern.Visitor<Optional<TypeCheckException>, PatternVisitorArgs> {
        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternVariant p, PatternVisitorArgs args) { /* Code for PatternVariant goes here */
            //p.stellaident_;
            //p.patterndata_.accept(new PatternDataVisitor<R, A>(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternInl p, PatternVisitorArgs args) { /* Code for PatternInl goes here */
            if (args.parentExprType instanceof TypeSum typeSum) {
                PatternVisitorArgs newArgs = new PatternVisitorArgs(
                        typeSum.type_1,
                        args.accessibleVariables,
                        args.accessibleFunctions,
                        args.functionName
                );
                return p.pattern_.accept(new PatternVisitor(), newArgs);
            } else {
                return Optional.of(IllegalExpressionException.illegalTypeSumReference(args.functionName));
            }
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternInr p, PatternVisitorArgs args) { /* Code for PatternInr goes here */
            if (args.parentExprType instanceof TypeSum typeSum) {
                PatternVisitorArgs newArgs = new PatternVisitorArgs(
                        typeSum.type_2,
                        args.accessibleVariables,
                        args.accessibleFunctions,
                        args.functionName
                );
                return p.pattern_.accept(new PatternVisitor(), newArgs);
            } else {
                return Optional.of(IllegalExpressionException.illegalTypeSumReference(args.functionName));
            }
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternTuple p, PatternVisitorArgs arg) { /* Code for PatternTuple goes here */
            for (org.syntax.stella.Absyn.Pattern x : p.listpattern_) {
                //x.accept(new PatternVisitor<R, A>(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternRecord p, PatternVisitorArgs arg) { /* Code for PatternRecord goes here */
            for (org.syntax.stella.Absyn.LabelledPattern x : p.listlabelledpattern_) {
                //x.accept(new LabelledPatternVisitor<R, A>(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternList p, PatternVisitorArgs arg) { /* Code for PatternList goes here */
            for (org.syntax.stella.Absyn.Pattern x : p.listpattern_) {
                //x.accept(new PatternVisitor<R, A>(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternCons p, PatternVisitorArgs arg) { /* Code for PatternCons goes here */
            //p.pattern_1.accept(new PatternVisitor<R, A>(), arg);
            //p.pattern_2.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternFalse p, PatternVisitorArgs arg) { /* Code for PatternFalse goes here */
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternTrue p, PatternVisitorArgs arg) { /* Code for PatternTrue goes here */
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternUnit p, PatternVisitorArgs arg) { /* Code for PatternUnit goes here */
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternInt p, PatternVisitorArgs arg) { /* Code for PatternInt goes here */
            //p.integer_;
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternSucc p, PatternVisitorArgs arg) { /* Code for PatternSucc goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.PatternVar p, PatternVisitorArgs args) { /* Code for PatternVar goes here */
            if (!p.stellaident_.equals("_"))
                args.accessibleVariables.put(p.stellaident_, args.parentExprType);
            return Optional.empty();
        }
    }

    public class LabelledPatternVisitor<R, A> implements org.syntax.stella.Absyn.LabelledPattern.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.ALabelledPattern p, A arg) { /* Code for ALabelledPattern goes here */
            //p.stellaident_;
            //p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }
    }

    //  public class BindingVisitor<R,A> implements org.syntax.stella.Absyn.Binding.Visitor<R,A>
//  {
//    public R visit(org.syntax.stella.Absyn.ABinding p, A arg)
//    { /* Code for ABinding goes here */
//      //p.stellaident_;
//      p.expr_.accept(new ExprVisitor<R,A>(), arg);
//      return null;
//    }
//  }
    public class ExprVisitor implements org.syntax.stella.Absyn.Expr.Visitor<Optional<TypeCheckException>, ExprVisitorArgs> {
        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Sequence p, ExprVisitorArgs expectedType) { /* Code for Sequence goes here */
            p.expr_1.accept(new ExprVisitor(), expectedType);
            p.expr_2.accept(new ExprVisitor(), expectedType);
            return null;
        }

        public Optional<TypeCheckException> visit(Assign p, ExprVisitorArgs expectedType) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.If p, ExprVisitorArgs args) { /* Code for If goes here */
            ExprVisitorArgs conditionArgs = new ExprVisitorArgs(
                    new TypeBool(),
                    args.functionName,
                    args.accessibleVariables,
                    args.accessibleFunctions,
                    new Stack<>()
            );
            Optional<TypeCheckException> wrongCond = acceptNullable(p.expr_1, new ExprVisitor(), conditionArgs);
            Optional<TypeCheckException> wrongArg1 = acceptNullable(p.expr_2, new ExprVisitor(), args);
            Optional<TypeCheckException> wrongArg2 = acceptNullable(p.expr_3, new ExprVisitor(), args);

            if (wrongCond.isPresent())
                return wrongCond;
            else if (wrongArg1.isPresent())
                return wrongArg1;
            else
                return wrongArg2;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Let p, ExprVisitorArgs arg) { /* Code for Let goes here */
            for (org.syntax.stella.Absyn.PatternBinding x : p.listpatternbinding_) {
                //x.accept(new PatternBindingVisitor<R,A>(), arg);
            }
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.LetRec p, ExprVisitorArgs arg) { /* Code for LetRec goes here */
            for (org.syntax.stella.Absyn.PatternBinding x : p.listpatternbinding_) {
                //x.accept(new PatternBindingVisitor<R,A>(), arg);
            }
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        @Override
        public Optional<TypeCheckException> visit(TypeAbstraction p, ExprVisitorArgs expectedType) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.LessThan p, ExprVisitorArgs arg) { /* Code for LessThan goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.LessThanOrEqual p, ExprVisitorArgs arg) { /* Code for LessThanOrEqual goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.GreaterThan p, ExprVisitorArgs arg) { /* Code for GreaterThan goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.GreaterThanOrEqual p, ExprVisitorArgs arg) { /* Code for GreaterThanOrEqual goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Equal p, ExprVisitorArgs arg) { /* Code for Equal goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.NotEqual p, ExprVisitorArgs arg) { /* Code for NotEqual goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.TypeAsc p, ExprVisitorArgs arg) { /* Code for TypeAsc goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            //p.type_.accept(new TypeVisitor<R,A>(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(TypeCast p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Abstraction p, ExprVisitorArgs args) { /* Code for Abstraction goes here */
            if (p.listparamdecl_.size() != 1)
                return Optional.of(FunctionDeclarationException.illegalParamsCount(args.functionName, p.listparamdecl_.size(), true));

            List<Type> expectedParamTypes = null;
            if (args.expectedType instanceof TypeFun expectedType) {
                expectedParamTypes = expectedType.listtype_;
            }

            List<FunctionParameter> params = new ArrayList<>();

            for (int i = 0; i < p.listparamdecl_.size(); i++) {
                int finalI = i;
                Optional<TypeCheckException> paramResult = p.listparamdecl_.get(i).accept(new ParamDeclVisitor(), new ParamDeclVisitorArgs(
                        Optional.ofNullable(expectedParamTypes).map(t -> t.get(finalI)),
                        args.functionName,
                        params,
                        args.accessibleFunctions.stream().map(f -> f.name).toList(),
                        true));
                if (paramResult.isPresent())
                    return paramResult;
            }

            for (FunctionParameter param : params) {
                if (args.accessibleVariables.keySet().stream().anyMatch(id -> id.equals(param.identifier)))
                    return Optional.of(FunctionDeclarationException.paramNameDuplicate(param.identifier, args.functionName, true));
            }

            if (!args.operations.isEmpty()) {
                List<FunctionParameter> parameters = new ArrayList<>();
                for (int i = 0; i < p.listparamdecl_.size(); i++) {
                    p.listparamdecl_.get(i).accept(new ParamDeclVisitor(), new ParamDeclVisitorArgs(
                            args.functionName,
                            parameters,
                            args.accessibleFunctions.stream().map(f -> f.name).toList(),
                            true));
                }

                ListType paramTypes = new ListType();
                paramTypes.addAll(parameters.stream().map(param -> param.type).toList());

                try {
                    Type returnType = getType(p.expr_, args.functionName, args.accessibleVariables, args.accessibleFunctions, args.operations);

                    return checkAppliedOperations(
                            "anonymous function",
                            new TypeFun(paramTypes, returnType),
                            args);
                } catch (TypeCheckException e) {
                    return Optional.of(e);
                }
            } else if (args.expectedType instanceof TypeFun expectedType) {
                Type returnType = expectedType.type_;
                Map<String, Type> extendedVariables = new HashMap<>(args.accessibleVariables);
                extendedVariables.putAll(
                        params
                                .stream()
                                .collect(
                                        Collectors.toMap(param -> param.identifier, param -> param.type)
                                )
                );
                ExprVisitorArgs newArgs = new ExprVisitorArgs(
                        returnType,
                        args.functionName,
                        extendedVariables,
                        args.accessibleFunctions,
                        new Stack<>()
                );

                return acceptNullable(p.expr_, new ExprVisitor(), newArgs);
            } else {
                return Optional.of(TypeMismatchException.unexpectedAbstraction(args.functionName, args.expectedType));
            }
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Variant p, ExprVisitorArgs arg) { /* Code for Variant goes here */
            //p.stellaident_;
            //p.exprdata_.accept(new ExprDataVisitor<R,A>(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Match p, ExprVisitorArgs args) { /* Code for Match goes here */
            Expr parentExpr = p.expr_;

            Optional<TypeCheckException> innerProblem = parentExpr.accept(
                    new ExprVisitor(),
                    new ExprVisitorArgs(
                            null,
                            args.functionName,
                            args.accessibleVariables,
                            args.accessibleFunctions,
                            new Stack<>())
            );
            if (innerProblem.isPresent())
                return innerProblem;

            try {
                TypeSum parentExprType = getSumType(
                        parentExpr,
                        args.functionName,
                        args.accessibleVariables,
                        args.accessibleFunctions,
                        new Stack<>());

                for (org.syntax.stella.Absyn.MatchCase matchCase : p.listmatchcase_) {

                    MatchCaseVisitorArgs matchCaseArgs = new MatchCaseVisitorArgs(
                            parentExprType,
                            args.expectedType,
                            args.accessibleVariables,
                            args.accessibleFunctions,
                            args.functionName
                    );
                    Optional<TypeCheckException> exceptionOptional = matchCase.accept(new MatchCaseVisitor(), matchCaseArgs);
                    if (exceptionOptional.isPresent())
                        return exceptionOptional;
                }
            } catch (TypeCheckException e) {
                return Optional.of(e);
            }

            return Optional.empty();
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.List p, ExprVisitorArgs arg) { /* Code for List goes here */
            for (org.syntax.stella.Absyn.Expr x : p.listexpr_) {
                x.accept(new ExprVisitor(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Add p, ExprVisitorArgs arg) { /* Code for Add goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Subtract p, ExprVisitorArgs arg) { /* Code for Subtract goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.LogicOr p, ExprVisitorArgs arg) { /* Code for LogicOr goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Multiply p, ExprVisitorArgs arg) { /* Code for Multiply goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Divide p, ExprVisitorArgs arg) { /* Code for Divide goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.LogicAnd p, ExprVisitorArgs arg) { /* Code for LogicAnd goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(Ref p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(Deref p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Application p, ExprVisitorArgs args) { /* Code for Application goes here */
            List<Expr> actualParameters = p.listexpr_;

            if (!(p.expr_ instanceof Var) && !(p.expr_ instanceof org.syntax.stella.Absyn.Application) && !(p.expr_ instanceof org.syntax.stella.Absyn.DotTuple) && !(p.expr_ instanceof org.syntax.stella.Absyn.Abstraction))
                return Optional.of(IllegalExpressionException.paramsToNonFunction(args.functionName, p.expr_.getClass().getSimpleName()));

            args.operations.add(new Application(actualParameters));
            return p.expr_.accept(new ExprVisitor(), args);
        }

        @Override
        public Optional<TypeCheckException> visit(TypeApplication p, ExprVisitorArgs expectedType) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.DotRecord p, ExprVisitorArgs arg) { /* Code for DotRecord goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            //p.stellaident_;
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.DotTuple p, ExprVisitorArgs args) { /* Code for DotTuple goes here */
            int dotTupleInt = p.integer_;

            args.operations.add(new DotTupleCall(dotTupleInt));
            return p.expr_.accept(new ExprVisitor(), args);
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Tuple p, ExprVisitorArgs args) { /* Code for Tuple goes here */
            Type typeTuple = new TypeTuple(new ListType());

            Optional<TypeCheckException> extensionProblem = checkExtension("#pairs", typeTuple, args);
            if (extensionProblem.isPresent())
                return extensionProblem;

            if (p.listexpr_.size() != 2) {
                return Optional.of(IllegalExpressionException.illegalTupleParamsCount(args.functionName, p.listexpr_.size()));
            }

            Stack<Operation> operations = args.operations;

            if (operations.isEmpty()) {
                if (args.expectedType instanceof TypeTuple expectedTuple) {
                    for (int i = 0; i < p.listexpr_.size(); i++) {
                        Type expectedType = expectedTuple.listtype_.get(i);
                        ExprVisitorArgs memberArgs = new ExprVisitorArgs(
                                expectedType,
                                args.functionName,
                                args.accessibleVariables,
                                args.accessibleFunctions,
                                new Stack<>()
                        );
                        Optional<TypeCheckException> result = acceptNullable(p.listexpr_.get(i), new ExprVisitor(), memberArgs);
                        if (result.isPresent())
                            return result;
                    }
                } else {
                    return Optional.of(TypeMismatchException.wrongType(args.functionName, args.expectedType, typeTuple));
                }
            } else {
                if (operations.peek() instanceof DotTupleCall dotTupleCall) {
                    operations.pop();
                    return p.listexpr_.get(dotTupleCall.dotTupleInteger - 1).accept(this, args);
                } else {
                    return Optional.of(IllegalExpressionException.paramsToNonFunction(args.functionName, p));
                }
            }

            return Optional.empty();
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Record p, ExprVisitorArgs arg) { /* Code for Record goes here */
            for (org.syntax.stella.Absyn.Binding x : p.listbinding_) {
                //x.accept(new BindingVisitor<R,A>(), arg);
            }
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.ConsList p, ExprVisitorArgs arg) { /* Code for ConsList goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Head p, ExprVisitorArgs arg) { /* Code for Head goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.IsEmpty p, ExprVisitorArgs arg) { /* Code for IsEmpty goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Tail p, ExprVisitorArgs arg) { /* Code for Tail goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(Panic p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(Throw p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(TryCatch p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(TryWith p, ExprVisitorArgs arg) {
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Inl p, ExprVisitorArgs args) { /* Code for Inl goes here */
            if (args.expectedType instanceof TypeSum) {
                ExprVisitorArgs newArgs = new ExprVisitorArgs(
                        ((TypeSum) args.expectedType).type_1,
                        args.functionName,
                        args.accessibleVariables,
                        args.accessibleFunctions,
                        new Stack<>()
                );
                return acceptNullable(p.expr_, new ExprVisitor(), newArgs);
            } else {
                return Optional.of(IllegalExpressionException.illegalTypeSumReference(args.functionName));
            }
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Inr p, ExprVisitorArgs args) { /* Code for Inr goes here */
            if (args.expectedType instanceof TypeSum) {
                ExprVisitorArgs newArgs = new ExprVisitorArgs(
                        ((TypeSum) args.expectedType).type_2,
                        args.functionName,
                        args.accessibleVariables,
                        args.accessibleFunctions,
                        new Stack<>()
                );
                return acceptNullable(p.expr_, new ExprVisitor(), newArgs);
            } else {
                return Optional.of(IllegalExpressionException.illegalTypeSumReference(args.functionName));
            }
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Succ p, ExprVisitorArgs args) { /* Code for Succ goes here */
            Type typeNat = new TypeNat();

            String functionName = p.getClass().getSimpleName();

            if (!args.expectedType.equals(typeNat)) {
                return Optional.of(TypeMismatchException.invalidArgumentType(args.functionName, functionName, typeNat, args.expectedType));
            }

            Optional<TypeCheckException> exprTypeException = checkExprType(args, typeNat);
            if (exprTypeException.isPresent())
                return exprTypeException;

            ExprVisitorArgs newArgs = new ExprVisitorArgs(
                    typeNat,
                    args.functionName,
                    args.accessibleVariables,
                    args.accessibleFunctions,
                    new Stack<>(),
                    functionName);

            return acceptNullable(p.expr_, new ExprVisitor(), newArgs);
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.LogicNot p, ExprVisitorArgs arg) { /* Code for LogicNot goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Pred p, ExprVisitorArgs arg) { /* Code for Pred goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.IsZero p, ExprVisitorArgs args) { /* Code for IsZero goes here */

            ExprVisitorArgs newArgs = new ExprVisitorArgs(
                    new TypeNat(),
                    args.functionName,
                    args.accessibleVariables,
                    args.accessibleFunctions,
                    args.operations
            );

            if (!(args.expectedType instanceof TypeBool))
                return Optional.of(TypeMismatchException.wrongType(args.functionName, args.expectedType, new TypeBool()));

            return p.expr_.accept(new ExprVisitor(), newArgs);
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Fix p, ExprVisitorArgs arg) { /* Code for Fix goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.NatRec p, ExprVisitorArgs args) { /* Code for NatRec goes here */
            ExprVisitorArgs argsForCounter = new ExprVisitorArgs(
                    new TypeNat(),
                    args.functionName,
                    args.accessibleVariables,
                    args.accessibleFunctions,
                    new Stack<>(),
                    "Nat::rec"
            );

            ExprVisitorArgs initialValueArgs = new ExprVisitorArgs(
                    args.expectedType,
                    args.functionName,
                    args.accessibleVariables,
                    args.accessibleFunctions,
                    new Stack<>(),
                    "Nat::rec"
            );

            ListType inputNumber = new ListType();
            inputNumber.add(new TypeNat());

            ListType paramTypesList = new ListType();
            paramTypesList.add(args.expectedType);

            ExprVisitorArgs inputFunctionArgs = new ExprVisitorArgs(
                    new TypeFun(inputNumber,
                            new TypeFun(
                                    paramTypesList,
                                    args.expectedType
                            )),
                    args.functionName,
                    args.accessibleVariables,
                    args.accessibleFunctions,
                    new Stack<>(),
                    "Nat::rec"
            );

            Optional<TypeCheckException> wrongCounter = acceptNullable(p.expr_1, new ExprVisitor(), argsForCounter);
            Optional<TypeCheckException> wrongInitialValue = acceptNullable(p.expr_2, new ExprVisitor(), initialValueArgs);
            Optional<TypeCheckException> wrongFunction = acceptNullable(p.expr_3, new ExprVisitor(), inputFunctionArgs);

            if (wrongCounter.isPresent())
                return wrongCounter;
            else if (wrongInitialValue.isPresent())
                return wrongInitialValue;
            else return wrongFunction;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Fold p, ExprVisitorArgs arg) { /* Code for Fold goes here */
            // p.type_.accept(new TypeVisitor<R,A>(), arg);
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Unfold p, ExprVisitorArgs arg) { /* Code for Unfold goes here */
            //p.type_.accept(new TypeVisitor<R,A>(), arg);
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.ConstTrue p, ExprVisitorArgs args) { /* Code for ConstTrue goes here */
            TypeBool typeBool = new TypeBool();

            return checkExprType(args, typeBool);
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.ConstFalse p, ExprVisitorArgs args) { /* Code for ConstFalse goes here */
            TypeBool typeBool = new TypeBool();

            return checkExprType(args, typeBool);
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.ConstUnit p, ExprVisitorArgs args) { /* Code for ConstUnit goes here */
            TypeUnit typeUnit = new TypeUnit();

            Optional<TypeCheckException> checked = checkExtension("#unit-type", typeUnit, args);
            if (checked.isPresent())
                return checked;

            return checkExprType(args, typeUnit);
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.ConstInt p, ExprVisitorArgs args) { /* Code for ConstInt goes here */
            int a = p.integer_;
            if (a != 0)
                return Optional.of(IllegalExpressionException.nonZeroInteger(args.functionName));
            return checkExprType(args, new TypeNat());
        }

        public Optional<TypeCheckException> visit(ConstMemory p, ExprVisitorArgs arg) {
            return null;
        }

        private Optional<TypeCheckException> checkParamsInAppliedFunction(String identifier, List<Type> expected, List<Expr> actualParams, ExprVisitorArgs args) {
            for (int j = 0; j < actualParams.size(); j++) {
                ExprVisitorArgs argsForParameter = new ExprVisitorArgs(
                        expected.get(j),
                        args.functionName,
                        args.accessibleVariables,
                        args.accessibleFunctions,
                        new Stack<>(),
                        identifier
                );
                Optional<TypeCheckException> result = actualParams.get(j).accept(new ExprVisitor(), argsForParameter);
                if (result.isPresent())
                    return result;
            }

            return Optional.empty();
        }

        private Optional<TypeCheckException> checkAppliedOperations(String identifier, Type returnType, ExprVisitorArgs args) {
            Stack<Operation> operations = args.operations;

            Type currentReturnType = returnType;

            if (operations.isEmpty())
                return checkExprType(args, returnType);

            while (!operations.isEmpty()) {
                Operation operation = operations.pop();

                if (operation instanceof Application application) {
                    if (currentReturnType instanceof TypeFun typeFun) {
                        Optional<TypeCheckException> result = checkParamsInAppliedFunction(
                                identifier,
                                typeFun.listtype_,
                                application.actualParams,
                                args);
                        if (result.isPresent())
                            return result;

                        currentReturnType = typeFun.type_;
                    } else {
                        return Optional.of(IllegalExpressionException.paramsToNonFunction(args.functionName, identifier));
                    }
                } else {
                    DotTupleCall dotTupleCall = (DotTupleCall) operation;
                    if (currentReturnType instanceof TypeTuple typeTuple) {
                        currentReturnType = typeTuple.listtype_.get(dotTupleCall.dotTupleInteger - 1);
                    } else {
                        return Optional.of(IllegalExpressionException.nonTupleDotCall(args.functionName));
                    }
                }
            }

            return checkExprType(args, currentReturnType);
        }

        public Optional<TypeCheckException> visit(org.syntax.stella.Absyn.Var p, ExprVisitorArgs args) { /* Code for Var goes here */
            String identifier = p.stellaident_;

            if (args.accessibleVariables.containsKey(identifier)) {
                Type variableType = args.accessibleVariables.get(identifier);
                return checkAppliedOperations(identifier, variableType, args);
            } else {
                Optional<FunctionInfo> appliedFunctionOpt = getFunctionByName(args.accessibleFunctions, identifier);
                if (appliedFunctionOpt.isPresent()) {
                    FunctionInfo appliedFunction = appliedFunctionOpt.get();

                    ListType params = new ListType();
                    params.addAll(appliedFunction.params.stream().map(param -> param.type).toList());

                    return checkAppliedOperations(
                            identifier,
                            new TypeFun(params, appliedFunction.returnType),
                            args);
                } else {
                    return Optional.of(UnknownIdentifierException.unknownVariable(identifier, args.functionName));
                }
            }
        }
    }

    public class PatternBindingVisitor<R, A> implements org.syntax.stella.Absyn.PatternBinding.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.APatternBinding p, A arg) { /* Code for APatternBinding goes here */
            //p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            //p.expr_.accept(new ExprVisitor<R,A>(), arg);
            return null;
        }
    }

    public class VariantFieldTypeVisitor<R, A> implements org.syntax.stella.Absyn.VariantFieldType.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.AVariantFieldType p, A arg) { /* Code for AVariantFieldType goes here */
            //p.stellaident_;
            p.optionaltyping_.accept(new OptionalTypingVisitor<R, A>(), arg);
            return null;
        }
    }

    public class RecordFieldTypeVisitor<R, A> implements org.syntax.stella.Absyn.RecordFieldType.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.ARecordFieldType p, A arg) { /* Code for ARecordFieldType goes here */
            //p.stellaident_;
            //p.type_.accept(new TypeVisitor<R,A>(), arg);
            return null;
        }
    }

    public class TypingVisitor<R, A> implements org.syntax.stella.Absyn.Typing.Visitor<R, A> {
        public R visit(org.syntax.stella.Absyn.ATyping p, A arg) { /* Code for ATyping goes here */
            //p.expr_.accept(new ExprVisitor<R,A>(), arg);
            //p.type_.accept(new TypeVisitor(), arg);
            return null;
        }
    }
}
